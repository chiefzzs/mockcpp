#include <testngpp/internal/TestCase.h>
#include <testngpp/internal/TestFixtureDesc.h>
#include <testngpp/internal/TestSuiteDesc.h>
#include <testngpp/internal/DataDriven.h>
#include </mnt/d/learnning/cmake/mockcpp/mockcpp/tests/ut/TestMethodInfoReader.h>

static struct TESTCASE_TestMethodInfoReader_testShouldBeAbleToCalcVptrIndex
   : public TESTNGPP_NS::TestCase
{
   TESTCASE_TestMethodInfoReader_testShouldBeAbleToCalcVptrIndex()
      : TESTNGPP_NS::TestCase
        ( "testShouldBeAbleToCalcVptrIndex"
        , "TestMethodInfoReader"
        , "TestMethodInfoReader"
        , 0
        , "TestMethodInfoReader.h"
        , 59)
   {}

   void setFixture(TESTNGPP_NS::TestFixture* fixture)
   {
      if(fixture == 0)
      {
         belongedFixture = new TestMethodInfoReader();
      }
      else
      {
         belongedFixture = dynamic_cast<TestMethodInfoReader*>(fixture);
      }
   }

   void runTest()
   {
      
belongedFixture->testShouldBeAbleToCalcVptrIndex()
;
   }

   TESTNGPP_NS::TestFixture* getFixture() const
   {
      return belongedFixture;
   }

   unsigned int numberOfTags() const
   {
      return 0;
   }

   const char** getTags() const
   {
      static const char* tags[] = {0};
      return tags;
   }

private:
   TestMethodInfoReader* belongedFixture;
} testcase_instance_TestMethodInfoReader_testShouldBeAbleToCalcVptrIndex ;



static struct TESTCASE_TestMethodInfoReader_testShouldBeAbleToCalcVptrByBaseClass
   : public TESTNGPP_NS::TestCase
{
   TESTCASE_TestMethodInfoReader_testShouldBeAbleToCalcVptrByBaseClass()
      : TESTNGPP_NS::TestCase
        ( "testShouldBeAbleToCalcVptrByBaseClass"
        , "TestMethodInfoReader"
        , "TestMethodInfoReader"
        , 0
        , "TestMethodInfoReader.h"
        , 85)
   {}

   void setFixture(TESTNGPP_NS::TestFixture* fixture)
   {
      if(fixture == 0)
      {
         belongedFixture = new TestMethodInfoReader();
      }
      else
      {
         belongedFixture = dynamic_cast<TestMethodInfoReader*>(fixture);
      }
   }

   void runTest()
   {
      
belongedFixture->testShouldBeAbleToCalcVptrByBaseClass()
;
   }

   TESTNGPP_NS::TestFixture* getFixture() const
   {
      return belongedFixture;
   }

   unsigned int numberOfTags() const
   {
      return 0;
   }

   const char** getTags() const
   {
      static const char* tags[] = {0};
      return tags;
   }

private:
   TestMethodInfoReader* belongedFixture;
} testcase_instance_TestMethodInfoReader_testShouldBeAbleToCalcVptrByBaseClass ;



static struct TESTCASE_TestMethodInfoReader_testShouldBeAbleToGetVtblIndex
   : public TESTNGPP_NS::TestCase
{
   TESTCASE_TestMethodInfoReader_testShouldBeAbleToGetVtblIndex()
      : TESTNGPP_NS::TestCase
        ( "testShouldBeAbleToGetVtblIndex"
        , "TestMethodInfoReader"
        , "TestMethodInfoReader"
        , 0
        , "TestMethodInfoReader.h"
        , 106)
   {}

   void setFixture(TESTNGPP_NS::TestFixture* fixture)
   {
      if(fixture == 0)
      {
         belongedFixture = new TestMethodInfoReader();
      }
      else
      {
         belongedFixture = dynamic_cast<TestMethodInfoReader*>(fixture);
      }
   }

   void runTest()
   {
      
belongedFixture->testShouldBeAbleToGetVtblIndex()
;
   }

   TESTNGPP_NS::TestFixture* getFixture() const
   {
      return belongedFixture;
   }

   unsigned int numberOfTags() const
   {
      return 0;
   }

   const char** getTags() const
   {
      static const char* tags[] = {0};
      return tags;
   }

private:
   TestMethodInfoReader* belongedFixture;
} testcase_instance_TestMethodInfoReader_testShouldBeAbleToGetVtblIndex ;



static struct TESTCASE_TestMethodInfoReader_testShouldBeEqualIf2MethodsDefinedInOneInterface
   : public TESTNGPP_NS::TestCase
{
   TESTCASE_TestMethodInfoReader_testShouldBeEqualIf2MethodsDefinedInOneInterface()
      : TESTNGPP_NS::TestCase
        ( "testShouldBeEqualIf2MethodsDefinedInOneInterface"
        , "TestMethodInfoReader"
        , "TestMethodInfoReader"
        , 0
        , "TestMethodInfoReader.h"
        , 118)
   {}

   void setFixture(TESTNGPP_NS::TestFixture* fixture)
   {
      if(fixture == 0)
      {
         belongedFixture = new TestMethodInfoReader();
      }
      else
      {
         belongedFixture = dynamic_cast<TestMethodInfoReader*>(fixture);
      }
   }

   void runTest()
   {
      
belongedFixture->testShouldBeEqualIf2MethodsDefinedInOneInterface()
;
   }

   TESTNGPP_NS::TestFixture* getFixture() const
   {
      return belongedFixture;
   }

   unsigned int numberOfTags() const
   {
      return 0;
   }

   const char** getTags() const
   {
      static const char* tags[] = {0};
      return tags;
   }

private:
   TestMethodInfoReader* belongedFixture;
} testcase_instance_TestMethodInfoReader_testShouldBeEqualIf2MethodsDefinedInOneInterface ;



static struct TESTCASE_TestMethodInfoReader_testShouldNotBeEqualIf2MethodsDefinedInDifferentBaseInterface
   : public TESTNGPP_NS::TestCase
{
   TESTCASE_TestMethodInfoReader_testShouldNotBeEqualIf2MethodsDefinedInDifferentBaseInterface()
      : TESTNGPP_NS::TestCase
        ( "testShouldNotBeEqualIf2MethodsDefinedInDifferentBaseInterface"
        , "TestMethodInfoReader"
        , "TestMethodInfoReader"
        , 0
        , "TestMethodInfoReader.h"
        , 124)
   {}

   void setFixture(TESTNGPP_NS::TestFixture* fixture)
   {
      if(fixture == 0)
      {
         belongedFixture = new TestMethodInfoReader();
      }
      else
      {
         belongedFixture = dynamic_cast<TestMethodInfoReader*>(fixture);
      }
   }

   void runTest()
   {
      
belongedFixture->testShouldNotBeEqualIf2MethodsDefinedInDifferentBaseInterface()
;
   }

   TESTNGPP_NS::TestFixture* getFixture() const
   {
      return belongedFixture;
   }

   unsigned int numberOfTags() const
   {
      return 0;
   }

   const char** getTags() const
   {
      static const char* tags[] = {0};
      return tags;
   }

private:
   TestMethodInfoReader* belongedFixture;
} testcase_instance_TestMethodInfoReader_testShouldNotBeEqualIf2MethodsDefinedInDifferentBaseInterface ;



static struct TESTCASE_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetVtblIndexOfANonVirtualMethod
   : public TESTNGPP_NS::TestCase
{
   TESTCASE_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetVtblIndexOfANonVirtualMethod()
      : TESTNGPP_NS::TestCase
        ( "testShouldThrowAnExceptionIfTryToGetVtblIndexOfANonVirtualMethod"
        , "TestMethodInfoReader"
        , "TestMethodInfoReader"
        , 0
        , "TestMethodInfoReader.h"
        , 129)
   {}

   void setFixture(TESTNGPP_NS::TestFixture* fixture)
   {
      if(fixture == 0)
      {
         belongedFixture = new TestMethodInfoReader();
      }
      else
      {
         belongedFixture = dynamic_cast<TestMethodInfoReader*>(fixture);
      }
   }

   void runTest()
   {
      
belongedFixture->testShouldThrowAnExceptionIfTryToGetVtblIndexOfANonVirtualMethod()
;
   }

   TESTNGPP_NS::TestFixture* getFixture() const
   {
      return belongedFixture;
   }

   unsigned int numberOfTags() const
   {
      return 0;
   }

   const char** getTags() const
   {
      static const char* tags[] = {0};
      return tags;
   }

private:
   TestMethodInfoReader* belongedFixture;
} testcase_instance_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetVtblIndexOfANonVirtualMethod ;



static struct TESTCASE_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetVptrIndexOfANonVirtualMethod
   : public TESTNGPP_NS::TestCase
{
   TESTCASE_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetVptrIndexOfANonVirtualMethod()
      : TESTNGPP_NS::TestCase
        ( "testShouldThrowAnExceptionIfTryToGetVptrIndexOfANonVirtualMethod"
        , "TestMethodInfoReader"
        , "TestMethodInfoReader"
        , 0
        , "TestMethodInfoReader.h"
        , 134)
   {}

   void setFixture(TESTNGPP_NS::TestFixture* fixture)
   {
      if(fixture == 0)
      {
         belongedFixture = new TestMethodInfoReader();
      }
      else
      {
         belongedFixture = dynamic_cast<TestMethodInfoReader*>(fixture);
      }
   }

   void runTest()
   {
      
belongedFixture->testShouldThrowAnExceptionIfTryToGetVptrIndexOfANonVirtualMethod()
;
   }

   TESTNGPP_NS::TestFixture* getFixture() const
   {
      return belongedFixture;
   }

   unsigned int numberOfTags() const
   {
      return 0;
   }

   const char** getTags() const
   {
      static const char* tags[] = {0};
      return tags;
   }

private:
   TestMethodInfoReader* belongedFixture;
} testcase_instance_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetVptrIndexOfANonVirtualMethod ;



static struct TESTCASE_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetAddressOfAVirtualMethod
   : public TESTNGPP_NS::TestCase
{
   TESTCASE_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetAddressOfAVirtualMethod()
      : TESTNGPP_NS::TestCase
        ( "testShouldThrowAnExceptionIfTryToGetAddressOfAVirtualMethod"
        , "TestMethodInfoReader"
        , "TestMethodInfoReader"
        , 0
        , "TestMethodInfoReader.h"
        , 139)
   {}

   void setFixture(TESTNGPP_NS::TestFixture* fixture)
   {
      if(fixture == 0)
      {
         belongedFixture = new TestMethodInfoReader();
      }
      else
      {
         belongedFixture = dynamic_cast<TestMethodInfoReader*>(fixture);
      }
   }

   void runTest()
   {
      
belongedFixture->testShouldThrowAnExceptionIfTryToGetAddressOfAVirtualMethod()
;
   }

   TESTNGPP_NS::TestFixture* getFixture() const
   {
      return belongedFixture;
   }

   unsigned int numberOfTags() const
   {
      return 0;
   }

   const char** getTags() const
   {
      static const char* tags[] = {0};
      return tags;
   }

private:
   TestMethodInfoReader* belongedFixture;
} testcase_instance_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetAddressOfAVirtualMethod ;



static TESTNGPP_NS::TestCase* g_TESTCASEARRAY_TestMethodInfoReader[] = {
&testcase_instance_TestMethodInfoReader_testShouldBeAbleToCalcVptrIndex,
&testcase_instance_TestMethodInfoReader_testShouldBeAbleToCalcVptrByBaseClass,
&testcase_instance_TestMethodInfoReader_testShouldBeAbleToGetVtblIndex,
&testcase_instance_TestMethodInfoReader_testShouldBeEqualIf2MethodsDefinedInOneInterface,
&testcase_instance_TestMethodInfoReader_testShouldNotBeEqualIf2MethodsDefinedInDifferentBaseInterface,
&testcase_instance_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetVtblIndexOfANonVirtualMethod,
&testcase_instance_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetVptrIndexOfANonVirtualMethod,
&testcase_instance_TestMethodInfoReader_testShouldThrowAnExceptionIfTryToGetAddressOfAVirtualMethod,
0
};




/*static*/ TESTNGPP_NS::TestFixtureDesc test_fixture_desc_instance_TestMethodInfoReader
   ( "TestMethodInfoReader"
   , "TestMethodInfoReader.h"
   , g_TESTCASEARRAY_TestMethodInfoReader
   , (sizeof(g_TESTCASEARRAY_TestMethodInfoReader)/sizeof(g_TESTCASEARRAY_TestMethodInfoReader[0])) - 1
   );



static TESTNGPP_NS::TestFixtureDesc* array_of_fixture_desc_TestMethodInfoReader[] = {
&test_fixture_desc_instance_TestMethodInfoReader,
0
};




static TESTNGPP_NS::TestSuiteDesc test_suite_desc_instance_TestMethodInfoReader
   ( "TestMethodInfoReader"
   , array_of_fixture_desc_TestMethodInfoReader
   , (sizeof(array_of_fixture_desc_TestMethodInfoReader)/sizeof(array_of_fixture_desc_TestMethodInfoReader[0])) - 1
   );



extern "C" DLL_EXPORT TESTNGPP_NS::TestSuiteDesc* ___testngpp_test_suite_desc_getter() {
   return &test_suite_desc_instance_TestMethodInfoReader;
}


